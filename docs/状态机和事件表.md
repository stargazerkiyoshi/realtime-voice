下面给你一份**可直接开工**的「状态机 + 事件表」（面向你要的：**打断 + 流式 + VAD**，并兼容 A/B/C 入口）。我按“会话级状态机（Session FSM）+ 轮次级子状态（Turn）”来设计，方便扩展强流程/Agent。

---

## 1) 会话状态机（Session FSM）

### 状态列表

* **IDLE**：未建立会话（仅内部态）
* **READY**：会话建立完成，等待音频/或等待接通
* **LISTENING**：正在听用户（VAD/ASR 流式进行）
* **THINKING**：用户一轮结束，正在规划/调用 LLM（可流式输出）
* **SPEAKING**：正在播报（TTS+播放队列）
* **TOOL_RUNNING**：正在执行工具（可并行于 THINKING 但建议先串行）
* **ENDING**：结束流程中（发挂机/资源回收）
* **ENDED**：会话结束（终态）

> 说明：
>
> * **LISTENING 与 SPEAKING 互斥**（便于打断逻辑清晰）。
> * 你想更激进的“边听边说”(full duplex) 以后再开，先把 barge-in 做稳。

---

## 2) 核心事件（Event）

我用统一事件名，A/B/C 入口都能发：

### 会话生命周期

* `E_SESSION_START(channel=A|B|C, meta)`
* `E_CONNECTED`（电话接通；Web 可直接触发 READY→LISTENING）
* `E_SESSION_END_REQUEST(reason)`（来自工具/外部）
* `E_REMOTE_HANGUP(reason)`（对端挂断）
* `E_ERROR(err)`

### 音频 / VAD / ASR

* `E_AUDIO_IN(chunk, ts)`
* `E_VAD_SPEECH_START(ts)`
* `E_VAD_SPEECH_END(ts)`
* `E_ASR_PARTIAL(text, ts)`
* `E_ASR_FINAL(text, ts, confidence)`

### 编排 / LLM / 输出

* `E_TURN_COMMIT(text)`（一轮用户输入确定：通常由 ASR_FINAL 触发）
* `E_LLM_TOKEN(text_delta)`（流式 token）
* `E_LLM_DONE(full_text)`
* `E_ASSISTANT_CHUNK(text_chunk)`（按句/分片后的文本块）
* `E_TTS_AUDIO(chunk)`
* `E_PLAYBACK_DRAINED`（播放队列清空）

### 工具

* `E_TOOL_CALL(name, args)`
* `E_TOOL_RESULT(name, ok, result_or_error)`

### 打断

* `E_BARGE_IN`（判定用户在 AI 播报时开口；一般由 VAD_SPEECH_START 触发）

---

## 3) 状态转换表（核心可执行版）

下面是“当前状态 + 事件 → 动作 + 下一状态”。动作我写成 `A_*` 便于你落到代码。

### 3.1 IDLE / READY

| 当前状态  | 事件                                      | 动作                               | 下一状态      |
| ----- | --------------------------------------- | -------------------------------- | --------- |
| IDLE  | E_SESSION_START                         | A_create_session, A_init_context | READY     |
| READY | E_CONNECTED（电话）                         | A_start_vad_asr                  | LISTENING |
| READY | （Web 直接）E_AUDIO_IN / 或自动触发              | A_start_vad_asr                  | LISTENING |
| READY | E_SESSION_END_REQUEST / E_REMOTE_HANGUP | A_cleanup                        | ENDED     |

### 3.2 LISTENING（收用户语音）

| 当前状态      | 事件                                      | 动作                                     | 下一状态      |
| --------- | --------------------------------------- | -------------------------------------- | --------- |
| LISTENING | E_AUDIO_IN                              | A_feed_vad, A_feed_asr_stream          | LISTENING |
| LISTENING | E_VAD_SPEECH_START                      | A_mark_user_speaking(true)             | LISTENING |
| LISTENING | E_ASR_PARTIAL                           | A_update_live_caption(optional)        | LISTENING |
| LISTENING | E_VAD_SPEECH_END                        | A_request_asr_finalize (or wait final) | LISTENING |
| LISTENING | E_ASR_FINAL                             | A_emit(E_TURN_COMMIT)                  | THINKING  |
| LISTENING | E_SESSION_END_REQUEST / E_REMOTE_HANGUP | A_cleanup                              | ENDED     |
| LISTENING | E_ERROR                                 | A_log, A_cleanup                       | ENDED     |

> 关键：**从 LISTENING→THINKING 的唯一硬触发**建议用 `ASR_FINAL`（更稳）。
> `VAD_SPEECH_END` 只是帮助你“催促 final”。

### 3.3 THINKING（规划/LLM）

| 当前状态     | 事件                                      | 动作                                                                   | 下一状态                           |
| -------- | --------------------------------------- | -------------------------------------------------------------------- | ------------------------------ |
| THINKING | E_TURN_COMMIT                           | A_append_user_history, A_orchestrator_plan_start, A_llm_stream_start | THINKING                       |
| THINKING | E_LLM_TOKEN                             | A_chunker_push, A_emit(E_ASSISTANT_CHUNK if ready)                   | THINKING                       |
| THINKING | E_ASSISTANT_CHUNK                       | A_tts_stream_start(chunk)                                            | SPEAKING *(见说明)*               |
| THINKING | E_TOOL_CALL                             | A_tool_execute_start                                                 | TOOL_RUNNING                   |
| THINKING | E_LLM_DONE                              | A_finalize_turn_plan                                                 | （若无输出且无工具）LISTENING / 或 ENDING |
| THINKING | E_SESSION_END_REQUEST / E_REMOTE_HANGUP | A_cancel_llm, A_cleanup                                              | ENDED                          |

**说明（重要）**：
为了更快首帧，你可以做 **THINKING→SPEAKING 的“抢占式切换”**：

* 一旦产生第一个 `ASSISTANT_CHUNK`，就转 SPEAKING，并允许在 SPEAKING 里继续接收后续 chunk（通过事件驱动继续 TTS）。

### 3.4 SPEAKING（TTS 播放中 + 支持打断）

| 当前状态     | 事件                                      | 动作                                                                                         | 下一状态                       |
| -------- | --------------------------------------- | ------------------------------------------------------------------------------------------ | -------------------------- |
| SPEAKING | E_ASSISTANT_CHUNK                       | A_tts_enqueue(chunk)                                                                       | SPEAKING                   |
| SPEAKING | E_TTS_AUDIO                             | A_playback_enqueue(audio)                                                                  | SPEAKING                   |
| SPEAKING | E_PLAYBACK_DRAINED                      | A_if_llm_done_then_listen_else_wait                                                        | LISTENING *(或保持 SPEAKING)* |
| SPEAKING | E_VAD_SPEECH_START                      | A_emit(E_BARGE_IN)                                                                         | SPEAKING                   |
| SPEAKING | E_BARGE_IN                              | **A_stop_playback, A_cancel_tts, A_cancel_llm_or_ignore, A_clear_queues, A_start_vad_asr** | LISTENING                  |
| SPEAKING | E_TOOL_CALL                             | A_tool_execute_start *(可选：先停播再工具)*                                                         | TOOL_RUNNING               |
| SPEAKING | E_SESSION_END_REQUEST / E_REMOTE_HANGUP | A_stop_playback, A_cleanup                                                                 | ENDED                      |

> 打断的“黄金动作序列”就四步：**停播→清队列→取消生成(或忽略)→回 LISTENING**。

### 3.5 TOOL_RUNNING（工具执行）

| 当前状态         | 事件                                      | 动作                                                               | 下一状态                         |
| ------------ | --------------------------------------- | ---------------------------------------------------------------- | ---------------------------- |
| TOOL_RUNNING | E_TOOL_RESULT(ok=true)                  | A_append_tool_history, A_continue_policy (may say/next tool/end) | THINKING / SPEAKING / ENDING |
| TOOL_RUNNING | E_TOOL_RESULT(ok=false)                 | A_append_tool_error, A_llm_recover_or_flow_retry                 | THINKING                     |
| TOOL_RUNNING | E_SESSION_END_REQUEST / E_REMOTE_HANGUP | A_cancel_tool, A_cleanup                                         | ENDED                        |

### 3.6 ENDING / ENDED

| 当前状态   | 事件   | 动作                            | 下一状态  |
| ------ | ---- | ----------------------------- | ----- |
| ENDING | （内部） | A_hangup_if_needed, A_cleanup | ENDED |

---

## 4) 一轮对话（Turn）子状态建议（可选但很实用）

在 session 里维护 `turn_id` 与 turn-phase，便于日志与调试：

* `TURN_LISTENING`：收音+ASR partial
* `TURN_FINALIZED`：拿到 ASR final
* `TURN_PLANNING`：策略/LLM 规划
* `TURN_SPEAKING`：TTS+播报
* `TURN_INTERRUPTED`：被 barge-in
* `TURN_DONE`

> 这不是额外 FSM，只是 turn-level 标记，日志会特别清晰。

---

## 5) 你可以直接照抄的“事件优先级规则”（避免竞态）

当同一时刻多个事件进来，按优先级处理：

1. `E_REMOTE_HANGUP / E_SESSION_END_REQUEST / E_ERROR`（立刻收尾）
2. `E_BARGE_IN`（立刻停播与取消）
3. `E_ASR_FINAL`（锁定本轮输入）
4. `E_TOOL_RESULT`（恢复流程）
5. `E_LLM_TOKEN / E_ASSISTANT_CHUNK / E_TTS_AUDIO`
6. `E_ASR_PARTIAL / E_AUDIO_IN`

---

## 6) MVP 强约束（让它“稳”）

* **任何时刻只能有一个 active LLM stream**（被打断就 cancel/ignore）
* **播放队列必须支持 stop+clear**（打断的基础）
* `ASR_FINAL` 到来后，为该 turn 固化文本，后续 partial 一律忽略（避免串轮）
* 工具调用必须走 `ToolExecutor`，LLM 不得直接产生“已发送/已挂断”这类事实性句子（由工具结果确认后再说）

---

如果你接下来要“可直接写代码”的版本，我建议下一步我给你：

* `StateMachine` 的伪代码（事件循环 + cancel token + 队列）
* `BargeInController` 的实现要点（怎么 stop playback、怎么取消 async task）
* `chunker` 的分片规则（按标点/字数/时间）——这会显著影响 1.5s 目标

你更偏 Python asyncio 还是 Node（TS）来做事件循环？我可以按你选的把核心 event-loop 骨架写出来。
