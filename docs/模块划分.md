好，我们先把模块划分定下来：**一套“核心内核 + 多入口适配 + 可插拔策略/工具”的分层架构**，保证 A/B/C 最小兼容、并且后续能无痛加 RAG/强流程/更多工具/多租户。

## 模块分层总览

### 0. 接入层 Ingress/Egress（A/B/C 适配器层）

* **Web/App Adapter（A）**：WebSocket 音频上行/下行、鉴权、会话建立
* **Telephony Inbound Adapter（B）**：SIP/VoIP 呼入接通、媒体流接入、挂机事件
* **Telephony Outbound Adapter（C）**：外呼拨号、接通检测、媒体流接入、挂机事件
* 统一输出：都转换成 `AudioIn` / `AudioOut` 接口 + `SessionStart/End` 事件

> 这层只做“把音频变成统一流”，不做对话逻辑。

---

## 1. 会话内核 Session Core（最重要）

**目标：一个 session = 一条音频会话 + 状态机 + 可取消任务编排**

* `SessionManager`：创建/销毁 session，维护会话表、路由 session_id
* `StateMachine`：Listening / Thinking / Speaking / ToolRunning / Ending
* `BargeInController`：打断控制（停止播放、取消生成、清空队列）
* `ContextStore`：会话级 history、短期记忆、临时变量（槽位、流程状态）
* `EventBus`：内部事件流（VAD、ASR partial/final、LLM token、TTS chunk、tool result）

---

## 2. 音频与识别链路 Audio Pipeline

* `AudioBuffer & Resampler`：采样率/声道统一、chunk 化
* `VAD Service`：speech_start/speech_end 检测（决定轮次边界）
* `ASR Service`：流式识别（partial + final），支持热词/语言模型配置（后续）
* 输出：`UserUtterance`（本轮用户文本 + 时间戳 + 置信度 + 可选对齐信息）

---

## 3. 对话编排 Orchestrator（策略层，可插拔）

统一接口：`plan(session, user_utterance) -> stream(assistant_actions)`
assistant_actions 可以是：

* `Say(text_chunk)`：要说的话（流式）
* `CallTool(name, args)`：请求工具调用
* `SwitchMode(mode)`：切换策略（流程/Agent）
* `End(reason)`：结束会话/转人工（后续）

内部实现两种策略（你说两种都要）：

1. `FlowPolicy（强流程）`

   * 流程定义（节点/条件/槽位/重试/超时）
   * LLM 用于意图识别、填槽、话术润色、异常分支
2. `AgentPolicy（知识库+工具调用）`

   * RAG 检索（后续加）
   * 工具调用规划（函数调用/JSON 协议）
   * 兜底策略（不知道就澄清/转人工）

> MVP 可以先把框架搭好，默认跑 FlowPolicy，也能随时切 AgentPolicy。

---

## 4. LLM 服务层 LLM Gateway

* `PromptBuilder`：系统提示词、会话上下文裁剪、强流程上下文注入
* `LLMClient`：统一封装不同厂商/自建模型（流式 token 输出）
* `OutputParser`：解析为 `Say / CallTool`（强约束：工具必须是合法结构）
* `Safety & Guardrails（可选）`：格式校验、最大长度、工具白名单

---

## 5. TTS 与播放链路 Speech Output

* `TTS Service`：把 text_chunk → audio_chunk（流式）
* `PlaybackQueue`：播放队列、支持 stop/clear（配合打断）
* `AudioOut Adapter`：把音频送回 WebSocket 或 电话媒体流

---

## 6. 工具系统 Tooling（第一期只做 2 个，但框架要通用）

* `ToolRegistry`：工具白名单、参数 schema、权限（后续租户隔离）
* `ToolExecutor`：执行工具（同步/异步）、超时、重试、错误标准化
* 内置工具（v0.1）：

  * `hangup`
  * `send_notification`
* 工具结果写入会话 history，供后续 LLM/流程继续对话

---

## 7. 观测与运维 Observability（第一期就要有，不然调不动）

* `Trace/Span`：每轮关键耗时（VAD→ASR→LLM→TTS→首帧播放）
* `Metrics`：并发 session 数、端到端延迟分布、ASR/LLM/TTS 错误率
* `Logs`：结构化日志（session_id、turn_id、state、事件）
* `Replay（可选）`：保存关键事件流用于复现（不含敏感数据时更容易）

---

# 关键接口（让模块真的“能拼起来”）

### 统一事件（建议最少就这些）

* `SessionStarted(session_id, channel=A|B|C)`
* `AudioChunkIn(session_id, bytes, ts)`
* `VadSpeechStart/End(session_id, ts)`
* `AsrPartial/Final(session_id, text, ts)`
* `AssistantTextChunk(session_id, text)`
* `TtsAudioChunk(session_id, bytes)`
* `BargeIn(session_id)`
* `ToolCallRequested/Result(session_id, name, args/result)`
* `SessionEnded(session_id, reason)`

---

# 最小目录结构（工程骨架）

```
/adapters
  /websocket
  /telephony_inbound
  /telephony_outbound
/core
  session_manager.py
  state_machine.py
  event_bus.py
  context_store.py
  barge_in.py
/audio
  vad.py
  asr.py
  audio_codec.py
/llm
  gateway.py
  prompt_builder.py
  output_parser.py
/orchestrator
  base_policy.py
  flow_policy.py
  agent_policy.py
/tts
  tts.py
  playback_queue.py
/tools
  registry.py
  executor.py
  builtins.py   # hangup/send_notification
/observability
  metrics.py
  tracing.py
  logger.py
```

---

## 接下来怎么推进（不需要你再解释一堆）

你现在只要选一个：**我们先从哪条链路开工验证？**

* 选项 1：先做 **A(Web/App)** 跑通（最快验证流式+打断+VAD）
* 选项 2：先做 **B/C 电话** 跑通（早期就面对最硬的媒体与生命周期）

你不用纠结，按“最快拿到可用 Demo”的原则一般选项 1。你回个“先A”或“先电话”，我就把对应模块的**接口定义 + 状态机表 + 线程/协程模型**直接给你，能马上开始写代码。
