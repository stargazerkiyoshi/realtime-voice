<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Voice AI Web Demo (PCM16 16k)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Microsoft Yahei, sans-serif; padding: 16px; }
    .row { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 12px; cursor: pointer; }
    #log { white-space: pre-wrap; background:#111; color:#0f0; padding: 10px; border-radius: 8px; height: 260px; overflow:auto; }
    .badge { display:inline-block; padding:2px 8px; border-radius: 999px; background:#eee; }
  </style>
</head>
<body>
  <h2>Voice AI Web Demo (PCM16 16k up, TTS down)</h2>

  <div class="row">
    <label>WS URL:</label>
    <input id="wsUrl" style="width:420px" />
    <span class="badge" id="wsState">DISCONNECTED</span>
  </div>

  <div class="row">
    <button id="btnConnect">Connect</button>
    <button id="btnStart" disabled>Start Mic</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnStopPlayback" disabled>Stop Playback</button>
  </div>

  <div class="row">
    <div>ASR:</div>
    <div id="asrText"></div>
  </div>

  <div class="row">
    <div>Assistant:</div>
    <div id="assistantText"></div>
  </div>

  <h3>Log</h3>
  <div id="log"></div>

<script>
(() => {
  // ====== 配置 ======
  const WS_URL_DEFAULT = "ws://localhost:8000/ws/voice";
  const TARGET_SR = 16000;          // 上行采样率
  const SEND_FRAME_MS = 20;         // 每包 20ms（推荐）
  const SEND_SAMPLES = TARGET_SR * SEND_FRAME_MS / 1000; // 320
  const SEND_BYTES = SEND_SAMPLES * 2;                   // 640 bytes

  // ====== UI ======
  const elUrl = document.getElementById("wsUrl");
  const elState = document.getElementById("wsState");
  const elLog = document.getElementById("log");
  const elAsr = document.getElementById("asrText");
  const elAssistant = document.getElementById("assistantText");
  const btnConnect = document.getElementById("btnConnect");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnStopPlayback = document.getElementById("btnStopPlayback");

  elUrl.value = WS_URL_DEFAULT;

  function log(...args) {
    const s = args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ");
    elLog.textContent += s + "\n";
    elLog.scrollTop = elLog.scrollHeight;
  }

  function setState(s) {
    elState.textContent = s;
  }

  // ====== WS ======
  let ws = null;
  let sessionId = crypto.randomUUID();
  let seq = 0;

  function wsSend(obj) {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  // ====== Audio Capture ======
  let audioCtx = null;
  let micStream = null;
  let sourceNode = null;
  let processorNode = null;

  // 用于把 float32 PCM（AudioContext 采样率）降采样到 16k PCM16
  function downsampleFloat32ToInt16(float32, inSampleRate, outSampleRate) {
    if (outSampleRate === inSampleRate) {
      const out = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        out[i] = (s < 0 ? s * 0x8000 : s * 0x7FFF) | 0;
      }
      return out;
    }

    const ratio = inSampleRate / outSampleRate;
    const outLen = Math.floor(float32.length / ratio);
    const out = new Int16Array(outLen);

    let pos = 0;
    for (let i = 0; i < outLen; i++) {
      const idx = i * ratio;
      const i0 = Math.floor(idx);
      const i1 = Math.min(i0 + 1, float32.length - 1);
      const frac = idx - i0;
      const sample = float32[i0] * (1 - frac) + float32[i1] * frac;

      let s = Math.max(-1, Math.min(1, sample));
      out[i] = (s < 0 ? s * 0x8000 : s * 0x7FFF) | 0;
      pos++;
    }
    return out;
  }

  function int16ToBase64(int16Arr) {
    const u8 = new Uint8Array(int16Arr.buffer);
    let bin = "";
    // 分块避免 call stack/内存炸
    const CHUNK = 0x8000;
    for (let i = 0; i < u8.length; i += CHUNK) {
      bin += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
    }
    return btoa(bin);
  }

  // ====== Playback (TTS) ======
  // 简化版：用 AudioBufferSourceNode 排队播放（MVP够用）
  let playbackCtx = null;
  let nextPlayTime = 0;
  let scheduledSources = [];

  function ensurePlaybackCtx() {
    if (!playbackCtx) playbackCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function stopPlayback() {
    for (const s of scheduledSources) {
      try { s.stop(); } catch {}
    }
    scheduledSources = [];
    if (playbackCtx) {
      nextPlayTime = playbackCtx.currentTime;
    } else {
      nextPlayTime = 0;
    }
    log("[playback] stopped");
  }

  function decodePayloadToUint8(payload) {
    // 兼容后端临时用 hex 发音频的情况（你骨架里 audio.hex()）
    const isLikelyHex = /^[0-9a-fA-F]+$/.test(payload) && (payload.length % 2 === 0);
    if (isLikelyHex) {
      const u8 = new Uint8Array(payload.length / 2);
      for (let i = 0; i < u8.length; i++) {
        u8[i] = parseInt(payload.substr(i * 2, 2), 16);
      }
      return u8;
    }
    // 正常 base64
    const bin = atob(payload);
    const u8 = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
    return u8;
  }

  function pcm16ToAudioBuffer(u8, sampleRate) {
    // u8 是 little-endian PCM16
    const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
    const len = u8.byteLength / 2;
    const float32 = new Float32Array(len);
    for (let i = 0; i < len; i++) {
      const v = view.getInt16(i * 2, true);
      float32[i] = v / 32768;
    }

    ensurePlaybackCtx();
    const buf = playbackCtx.createBuffer(1, float32.length, sampleRate);
    buf.getChannelData(0).set(float32);
    return buf;
  }

  function enqueuePcm16ForPlay(u8, sampleRate) {
    ensurePlaybackCtx();

    // 播放时间推进：把 chunk 串起来
    const buf = pcm16ToAudioBuffer(u8, sampleRate);
    const src = playbackCtx.createBufferSource();
    src.buffer = buf;
    src.connect(playbackCtx.destination);

    const now = playbackCtx.currentTime;
    if (nextPlayTime < now) nextPlayTime = now;

    src.start(nextPlayTime);
    scheduledSources.push(src);

    nextPlayTime += buf.duration;

    // 播完自动从数组移除
    src.onended = () => {
      scheduledSources = scheduledSources.filter(x => x !== src);
    };
  }

  // ====== Mic Start/Stop ======
  // 用 ScriptProcessorNode（虽是 deprecated，但 MVP 够快够省事；后续可换 AudioWorklet）
  let sendBuffer = new Int16Array(0);

  function appendInt16(a, b) {
    const out = new Int16Array(a.length + b.length);
    out.set(a, 0);
    out.set(b, a.length);
    return out;
  }

  async function startMic() {
    if (!ws || ws.readyState !== 1) throw new Error("WS not connected");

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();
    ensurePlaybackCtx();
    await playbackCtx.resume?.();

    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    sourceNode = audioCtx.createMediaStreamSource(micStream);

    // 4096 buffer 比较稳；你也可以改 2048 降低延迟
    processorNode = audioCtx.createScriptProcessor(4096, 1, 1);

    processorNode.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0); // Float32
      const inSR = audioCtx.sampleRate;

      // 降采样 + 转 int16
      const int16 = downsampleFloat32ToInt16(input, inSR, TARGET_SR);

      // 按 20ms 打包发送
      sendBuffer = appendInt16(sendBuffer, int16);
      while (sendBuffer.length >= SEND_SAMPLES) {
        const frame = sendBuffer.slice(0, SEND_SAMPLES);
        sendBuffer = sendBuffer.slice(SEND_SAMPLES);

        const payload_b64 = int16ToBase64(frame);
        wsSend({ type: "audio", seq: seq++, ts_ms: Date.now(), payload_b64 });
      }
    };

    sourceNode.connect(processorNode);
    processorNode.connect(audioCtx.destination); // 不想回放麦克风可不连 destination，但有些浏览器需要接通链路

    wsSend({ type: "start", session_id: sessionId, format: "pcm16", sample_rate: TARGET_SR, lang: "zh" });

    btnStart.disabled = true;
    btnStop.disabled = false;
    btnStopPlayback.disabled = false;

    log("[mic] started", "audioCtx.sampleRate=", audioCtx.sampleRate);
  }

  async function stopAll(reason = "user_stop") {
    wsSend({ type: "stop", reason });

    if (processorNode) {
      processorNode.disconnect();
      processorNode.onaudioprocess = null;
      processorNode = null;
    }
    if (sourceNode) {
      sourceNode.disconnect();
      sourceNode = null;
    }
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if (audioCtx) {
      try { await audioCtx.close(); } catch {}
      audioCtx = null;
    }
    stopPlayback();

    btnStart.disabled = false;
    btnStop.disabled = true;
    btnStopPlayback.disabled = true;

    log("[mic] stopped");
  }

  // ====== Buttons ======
  btnConnect.onclick = () => {
    const url = elUrl.value.trim();
    if (!url) return;

    ws = new WebSocket(url);
    setState("CONNECTING...");

    ws.onopen = () => {
      setState("CONNECTED");
      log("[ws] open", url);
      btnStart.disabled = false;
    };

    ws.onclose = () => {
      setState("DISCONNECTED");
      log("[ws] close");
      btnStart.disabled = true;
      btnStop.disabled = true;
      btnStopPlayback.disabled = true;
    };

    ws.onerror = () => log("[ws] error");

    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "ready") {
        log("[server] ready", msg.session_id);
      } else if (msg.type === "vad") {
        log("[vad]", msg.event);
      } else if (msg.type === "asr") {
        elAsr.textContent = (msg.is_final ? "[final] " : "[partial] ") + msg.text;
      } else if (msg.type === "assistant") {
        elAssistant.textContent += msg.text;
      } else if (msg.type === "tts") {
        // 播放 TTS 音频
        const u8 = decodePayloadToUint8(msg.payload_b64);
        enqueuePcm16ForPlay(u8, msg.sample_rate || 24000);
      } else if (msg.type === "barge_in") {
        log("[barge_in] stop playback");
        stopPlayback();
      } else if (msg.type === "end") {
        log("[server] end", msg.reason);
      } else if (msg.type === "error") {
        log("[server] error", msg.code, msg.message);
      }
    };
  };

  btnStart.onclick = async () => {
    elAssistant.textContent = "";
    elAsr.textContent = "";
    sendBuffer = new Int16Array(0);
    sessionId = crypto.randomUUID();
    seq = 0;
    await startMic();
  };

  btnStop.onclick = async () => {
    await stopAll("user_stop");
  };

  btnStopPlayback.onclick = () => stopPlayback();

})();
</script>
</body>
</html>
